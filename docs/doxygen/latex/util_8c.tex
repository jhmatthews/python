\hypertarget{util_8c}{}\section{/\+Users/mhewitt/python/source/util.c File Reference}
\label{util_8c}\index{/\+Users/mhewitt/python/source/util.\+c@{/\+Users/mhewitt/python/source/util.\+c}}


These are very simple utilities within Python that do not fall into a larger catergory like those in vector.  


{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$math.\+h$>$}\newline
{\ttfamily \#include \char`\"{}log.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}atomic.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}python.\+h\char`\"{}}\newline
Include dependency graph for util.\+c\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{util_8c__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{util_8c_adb5b0074d608e468f0d9a9f8493d4154}{fraction} (double value, array, int npts, int $\ast$ival, double $\ast$f, int mode)
\begin{DoxyCompactList}\small\item\em Perform linear/logarithmic interpolation of an array. \end{DoxyCompactList}\item 
int \hyperlink{util_8c_a1fac68a4c0528ac8613fcaf975ddfd58}{linterp} (double \hyperlink{import__cylindrical_8c_a099bc7b5a9501685180c163c1ffb67d0}{x}, xarray, yarray, int xdim, double $\ast$y, int mode)
\begin{DoxyCompactList}\small\item\em Perform a linear interpolation on two parallel arrays, the fist of which contains a set of values to be interpolated and the second of which has the function at those values. \end{DoxyCompactList}\item 
int \hyperlink{util_8c_a58278ee8209899477833e9415625667b}{coord\+\_\+fraction} (int ndom, int ichoice, \hyperlink{import__cylindrical_8c_a099bc7b5a9501685180c163c1ffb67d0}{x}, ii, frac, int $\ast$nelem)
\begin{DoxyCompactList}\small\item\em calculate the fractional contributions in interpolations of values of quantities, such as electron density, by various cells in the grid in a coordinate system independent way. \end{DoxyCompactList}\item 
int \hyperlink{util_8c_ad7e07bac9d1bcabdcca0c8f77e164309}{where\+\_\+in\+\_\+2dcell} (int ichoice, \hyperlink{import__cylindrical_8c_a099bc7b5a9501685180c163c1ffb67d0}{x}, int n, double $\ast$fx, double $\ast$fz)
\begin{DoxyCompactList}\small\item\em calculates the fractional location of a position in any 2d grid. \end{DoxyCompactList}\item 
int \hyperlink{util_8c_aed64e9379499a741e8a7c42376e20530}{wind\+\_\+n\+\_\+to\+\_\+ij} (int ndom, int n, int $\ast$\hyperlink{import__rtheta_8c_ab47e1e72aea1af4158c96f38ee80b8f7}{i}, int $\ast$\hyperlink{import__rtheta_8c_ad9db47ad8a21025384c0b7f8fc0a61cc}{j})
\begin{DoxyCompactList}\small\item\em Translate a cell number in the wind to the two-\/d grid position in a specific domain. \end{DoxyCompactList}\item 
int \hyperlink{util_8c_a172ddeb06a81951700723a0b02d90557}{wind\+\_\+ij\+\_\+to\+\_\+n} (int ndom, int \hyperlink{import__rtheta_8c_ab47e1e72aea1af4158c96f38ee80b8f7}{i}, int \hyperlink{import__rtheta_8c_ad9db47ad8a21025384c0b7f8fc0a61cc}{j}, int $\ast$n)
\begin{DoxyCompactList}\small\item\em Translate from the 2d element for an individual domain to the wind element number. \end{DoxyCompactList}\item 
int \hyperlink{util_8c_ad2938cb78e3414274491d2d778843db3}{wind\+\_\+x\+\_\+to\+\_\+n} (double \hyperlink{import__cylindrical_8c_a099bc7b5a9501685180c163c1ffb67d0}{x}\mbox{[}$\,$\mbox{]}, int $\ast$n)
\begin{DoxyCompactList}\small\item\em Determine the wind domain element number from a postion. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{util_8c_a8c064433c3cb416cc54ca16016f1f580}{ierr\+\_\+coord\+\_\+fraction} = 0
\item 
int \hyperlink{util_8c_a0f0c8239c80e4ad569d9c18782b6f5cc}{ierr\+\_\+where\+\_\+in\+\_\+2dcell} = 0
\end{DoxyCompactItemize}


\subsection{Detailed Description}
These are very simple utilities within Python that do not fall into a larger catergory like those in vector. 

\begin{DoxyAuthor}{Author}
ksl 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
April, 2018
\end{DoxyDate}
\paragraph*{Notes}

These routines should probably be refactored into other routines

It may be useful to rethink them in addition, as they were all written prior to the existence of domains, and domains are just grafted on. 

\subsection{Function Documentation}
\mbox{\Hypertarget{util_8c_a58278ee8209899477833e9415625667b}\label{util_8c_a58278ee8209899477833e9415625667b}} 
\index{util.\+c@{util.\+c}!coord\+\_\+fraction@{coord\+\_\+fraction}}
\index{coord\+\_\+fraction@{coord\+\_\+fraction}!util.\+c@{util.\+c}}
\subsubsection{\texorpdfstring{coord\+\_\+fraction()}{coord\_fraction()}}
{\footnotesize\ttfamily int coord\+\_\+fraction (\begin{DoxyParamCaption}\item[{int}]{ndom,  }\item[{int}]{ichoice,  }\item[{\hyperlink{import__cylindrical_8c_a099bc7b5a9501685180c163c1ffb67d0}{x}}]{,  }\item[{ii}]{,  }\item[{frac}]{,  }\item[{int $\ast$}]{nelem }\end{DoxyParamCaption})}



calculate the fractional contributions in interpolations of values of quantities, such as electron density, by various cells in the grid in a coordinate system independent way. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em int} & ndom The domain in where the interpolation will take place \\
\hline
\mbox{\tt in}  & {\em int} & ichoice interpolate on vertices (0), interpolate on centers (1)$>$ \\
\hline
\mbox{\tt in}  & {\em double} & x\mbox{[}\mbox{]} the 3-\/vector position for which you want the fractinal position \\
\hline
\mbox{\tt out}  & {\em int} & ii\mbox{[}\mbox{]} an array that contains the 1-\/d element numbers that must be summed \\
\hline
\mbox{\tt out}  & {\em double} & frac\mbox{[}\mbox{]} the array that contains the fractional contribution of the corresponding element \\
\hline
\mbox{\tt out}  & {\em int} & $\ast$ nelem the number of elements that must be summed, nominally 2 for a spherical grid and 4 for a two dimensional grid. (For a 3 d grid it would be 6, but we have not implemented this.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if inside the grid -\/2 if outside the grid -\/1 if inside the grid
\end{DoxyReturn}
\paragraph*{Notes}

There are numerous times when one wants the value of an interpoalted variable in the wind. There is no easy way to interpolate the variable easily. What this routine does is calculate the fractional contributions of elements in the array to that position. Then one must sum up the actual variable else where

If positions are outside the grid, coord\+\_\+fraction attempts to give you the value at the edge of the grid.

It\textquotesingle{}s possible that coord\+\_\+fraction could be used to interpolate beyond the edge of the grid where a variable is defined, although this is not done at present! 

Definition at line 277 of file util.\+c.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{util_8c_a58278ee8209899477833e9415625667b_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{util_8c_adb5b0074d608e468f0d9a9f8493d4154}\label{util_8c_adb5b0074d608e468f0d9a9f8493d4154}} 
\index{util.\+c@{util.\+c}!fraction@{fraction}}
\index{fraction@{fraction}!util.\+c@{util.\+c}}
\subsubsection{\texorpdfstring{fraction()}{fraction()}}
{\footnotesize\ttfamily int fraction (\begin{DoxyParamCaption}\item[{double}]{value,  }\item[{array}]{,  }\item[{int}]{npts,  }\item[{int $\ast$}]{ival,  }\item[{double $\ast$}]{f,  }\item[{int}]{mode }\end{DoxyParamCaption})}



Perform linear/logarithmic interpolation of an array. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em double} & value The value used for interpoaltion \\
\hline
\mbox{\tt in}  & {\em double} & array\mbox{[}\mbox{]} An array containing a set of asceding values \\
\hline
\mbox{\tt in}  & {\em int} & npts The size of the array \\
\hline
\mbox{\tt out}  & {\em int} & $\ast$ ival The lower index to use in the interpolation of the array which need to be used to interpolate on \\
\hline
\mbox{\tt out}  & {\em double} & $\ast$ f The fraction of the upper point to use in the interpolation \\
\hline
\mbox{\tt in}  & {\em int} & mode A switch to choose linear(0) or lograrithmic(1) interpolation \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Usually returns 0, but returns -\/1 if the input value is less than the first elememnt in the array, and 1 if it is greater than the last element int he array. In either of these cases, the fractions are set up only to access one array element
\end{DoxyReturn}
Typically one has two parallel arrays, one containing a set of values, in the original case frequencies, and another containing some function of those values. This routine finds the fraction of the function at two point in the data array to interpolate.

The values for the input array can be interpolated linear or logarithmically. that is the fraction that is returned are based on the values in the array or the logarithm of them.

The routine uses bisection

\paragraph*{Notes}

fraction is a utility written to speed up the search for the bracketing topbase photionization x-\/sections, but in principle it should work in other situations within python (which at one time at least contributed significantly to the runtime for Python).

Today, fraction is called directly in the routines that are used to set up coordinate systems, and indirectly through linterp (below) which should be inspected to see how the logarithmic interpolation is supposed to work.

The routine is similar to the numerical $\ast$ recipes routine locate. There may be a gsl routine as well. The routine should probably be replaced. 

Definition at line 87 of file util.\+c.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{util_8c_adb5b0074d608e468f0d9a9f8493d4154_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=221pt]{util_8c_adb5b0074d608e468f0d9a9f8493d4154_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{util_8c_a1fac68a4c0528ac8613fcaf975ddfd58}\label{util_8c_a1fac68a4c0528ac8613fcaf975ddfd58}} 
\index{util.\+c@{util.\+c}!linterp@{linterp}}
\index{linterp@{linterp}!util.\+c@{util.\+c}}
\subsubsection{\texorpdfstring{linterp()}{linterp()}}
{\footnotesize\ttfamily int linterp (\begin{DoxyParamCaption}\item[{double}]{x,  }\item[{xarray}]{,  }\item[{yarray}]{,  }\item[{int}]{xdim,  }\item[{double $\ast$}]{y,  }\item[{int}]{mode }\end{DoxyParamCaption})}



Perform a linear interpolation on two parallel arrays, the fist of which contains a set of values to be interpolated and the second of which has the function at those values. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em double} & x A value \\
\hline
\mbox{\tt in}  & {\em double} & xarray\mbox{[}\mbox{]} The array that is interplated \\
\hline
\mbox{\tt in}  & {\em double} & yarray\mbox{[}\mbox{]} The array that contains a function of the values in xaray \\
\hline
\mbox{\tt in}  & {\em int} & xdim The length of the two arrays \\
\hline
\mbox{\tt out}  & {\em double} & $\ast$ y The resulting intepolated value \\
\hline
\mbox{\tt in}  & {\em int} & mode A switch to choose linear(0) or \char`\"{}logarithmic\char`\"{} (1) interpolation\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of the array element that is used for the lower of the two elements taht are intepolated on.
\end{DoxyReturn}
Given a number x, and an array of x\textquotesingle{}s in xarray, and functional values y = f(x) in yarray and the dimension of xarray and yarray, linterp calculates y, the linearly interpolated value of y(x). It also returns the element in the xarray so that one can consider not doing a search to find the right array element in certain circumstances

\paragraph*{Notes}

For mode 0, the value that is retuned is

(1-\/f)$\ast$y\mbox{[}nelem\mbox{]}+f$\ast$\mbox{[}nelem+1)

For mode 1, the value returned is exp ((1. -\/ f) $\ast$ log (y\mbox{[}nelem\mbox{]}) + f $\ast$ log (y\mbox{[}nelem + 1\mbox{]})) 

Definition at line 194 of file util.\+c.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{util_8c_a1fac68a4c0528ac8613fcaf975ddfd58_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{util_8c_ad7e07bac9d1bcabdcca0c8f77e164309}\label{util_8c_ad7e07bac9d1bcabdcca0c8f77e164309}} 
\index{util.\+c@{util.\+c}!where\+\_\+in\+\_\+2dcell@{where\+\_\+in\+\_\+2dcell}}
\index{where\+\_\+in\+\_\+2dcell@{where\+\_\+in\+\_\+2dcell}!util.\+c@{util.\+c}}
\subsubsection{\texorpdfstring{where\+\_\+in\+\_\+2dcell()}{where\_in\_2dcell()}}
{\footnotesize\ttfamily int where\+\_\+in\+\_\+2dcell (\begin{DoxyParamCaption}\item[{int}]{ichoice,  }\item[{\hyperlink{import__cylindrical_8c_a099bc7b5a9501685180c163c1ffb67d0}{x}}]{,  }\item[{int}]{n,  }\item[{double $\ast$}]{fx,  }\item[{double $\ast$}]{fz }\end{DoxyParamCaption})}



calculates the fractional location of a position in any 2d grid. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em int} & ichoice interpolate on vertices (0) or centers (1) \\
\hline
\mbox{\tt in}  & {\em double} & x\mbox{[}\mbox{]} the 3-\/vector position for which you want the fractinal position \\
\hline
\mbox{\tt in,out}  & {\em int} & n The cell number in wmain \\
\hline
\mbox{\tt out}  & {\em double} & $\ast$ fx Fractional position in the x (1st) direction \\
\hline
\mbox{\tt out}  & {\em double} & $\ast$ fz fracitionl postion in the z (2nd) direction \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if the positiion is within the cell as defined, non-\/zero otherwise
\end{DoxyReturn}
The routine provides the fractions need to interpopolate variables, such as ne, in the wind. It is called when one already knows what cell one is in. Like many other routines one can intepolate using the boundaries of the wind cell for values which are defined there (like velocity), and values defined at the cell centeres (like densities)

\paragraph*{Notes}

This routine is general. It does not rely on the predefined arrays that just contain the grid vertices and centers. On the other hand, it does not calculate which grid cell x lies in. It only tells you that x is not in a particular cell if that is the case.

A cell is organized as follows\+:


\begin{DoxyItemize}
\item x01 x11
\item x00 x10
\end{DoxyItemize}

This routine was written to account for cylind\+\_\+var coordiantes 

Definition at line 443 of file util.\+c.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{util_8c_ad7e07bac9d1bcabdcca0c8f77e164309_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{util_8c_a172ddeb06a81951700723a0b02d90557}\label{util_8c_a172ddeb06a81951700723a0b02d90557}} 
\index{util.\+c@{util.\+c}!wind\+\_\+ij\+\_\+to\+\_\+n@{wind\+\_\+ij\+\_\+to\+\_\+n}}
\index{wind\+\_\+ij\+\_\+to\+\_\+n@{wind\+\_\+ij\+\_\+to\+\_\+n}!util.\+c@{util.\+c}}
\subsubsection{\texorpdfstring{wind\+\_\+ij\+\_\+to\+\_\+n()}{wind\_ij\_to\_n()}}
{\footnotesize\ttfamily int wind\+\_\+ij\+\_\+to\+\_\+n (\begin{DoxyParamCaption}\item[{int}]{ndom,  }\item[{int}]{i,  }\item[{int}]{j,  }\item[{int $\ast$}]{n }\end{DoxyParamCaption})}



Translate from the 2d element for an individual domain to the wind element number. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em int} & ndom The domain of interest \\
\hline
\mbox{\tt in,out}  & {\em int} & i The element number for the first (x) dimension \\
\hline
\mbox{\tt in,out}  & {\em int} & j The element number fro the second (z or theta) dimension \\
\hline
\mbox{\tt in,out}  & {\em int} & $\ast$ n The element number in the wind \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The element number is returned
\end{DoxyReturn}
This is just a simple translation to find the wind domain element number

\paragraph*{Notes}

Definition at line 575 of file util.\+c.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{util_8c_a172ddeb06a81951700723a0b02d90557_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{util_8c_a172ddeb06a81951700723a0b02d90557_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{util_8c_aed64e9379499a741e8a7c42376e20530}\label{util_8c_aed64e9379499a741e8a7c42376e20530}} 
\index{util.\+c@{util.\+c}!wind\+\_\+n\+\_\+to\+\_\+ij@{wind\+\_\+n\+\_\+to\+\_\+ij}}
\index{wind\+\_\+n\+\_\+to\+\_\+ij@{wind\+\_\+n\+\_\+to\+\_\+ij}!util.\+c@{util.\+c}}
\subsubsection{\texorpdfstring{wind\+\_\+n\+\_\+to\+\_\+ij()}{wind\_n\_to\_ij()}}
{\footnotesize\ttfamily int wind\+\_\+n\+\_\+to\+\_\+ij (\begin{DoxyParamCaption}\item[{int}]{ndom,  }\item[{int}]{n,  }\item[{int $\ast$}]{i,  }\item[{int $\ast$}]{j }\end{DoxyParamCaption})}



Translate a cell number in the wind to the two-\/d grid position in a specific domain. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em int} & ndom The domain of interest \\
\hline
\mbox{\tt in}  & {\em int} & n The 1-\/d position in the wind domain \\
\hline
\mbox{\tt out}  & {\em int} & $\ast$ i The first index for a 2d position in a given domain \\
\hline
\mbox{\tt out}  & {\em int} & $\ast$ j The second index for a 2d postion in a given domain \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
i,j position in a given domain
\end{DoxyReturn}
wmain contains elements for the entire winds. This routine translates from a wmain index to the two-\/d index of a specific domain so that one can interpolate.

\paragraph*{Notes}

For 2d, the underlying 1-\/d grid is organized so that as n increases, one goes up in z, and then steps out in rho., or in theta and then z as the case may be.

With domains, this routine has to be used carefully, and a better statement would be that these routines map to and from the element in wmain to the normally 2d element in an individual domain.

So this means that if you want to get the ith and jth element of domain 1, then one needs to give nstart+whatever to wind\+\_\+n\+\_\+to\+\_\+ij 

Definition at line 539 of file util.\+c.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{util_8c_aed64e9379499a741e8a7c42376e20530_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{util_8c_ad2938cb78e3414274491d2d778843db3}\label{util_8c_ad2938cb78e3414274491d2d778843db3}} 
\index{util.\+c@{util.\+c}!wind\+\_\+x\+\_\+to\+\_\+n@{wind\+\_\+x\+\_\+to\+\_\+n}}
\index{wind\+\_\+x\+\_\+to\+\_\+n@{wind\+\_\+x\+\_\+to\+\_\+n}!util.\+c@{util.\+c}}
\subsubsection{\texorpdfstring{wind\+\_\+x\+\_\+to\+\_\+n()}{wind\_x\_to\_n()}}
{\footnotesize\ttfamily int wind\+\_\+x\+\_\+to\+\_\+n (\begin{DoxyParamCaption}\item[{double}]{x\mbox{[}$\,$\mbox{]},  }\item[{int $\ast$}]{n }\end{DoxyParamCaption})}



Determine the wind domain element number from a postion. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em double} & x\mbox{[}\mbox{]} A three vector describing a position \\
\hline
\mbox{\tt out}  & {\em int} & $\ast$ n The element number in the wind domain \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Also retruns the element number in the wind domain
\end{DoxyReturn}
The routine simply cycles through the various domains until if finds one in where x is in that domain.

\paragraph*{Notes}

\begin{DoxyRefDesc}{Bug}
\item[\hyperlink{bug__bug000061}{Bug}]There are no checks for whether x is within the wind. This seems very dangerous.\end{DoxyRefDesc}


Definition at line 610 of file util.\+c.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{util_8c_ad2938cb78e3414274491d2d778843db3_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=227pt]{util_8c_ad2938cb78e3414274491d2d778843db3_icgraph}
\end{center}
\end{figure}


\subsection{Variable Documentation}
\mbox{\Hypertarget{util_8c_a8c064433c3cb416cc54ca16016f1f580}\label{util_8c_a8c064433c3cb416cc54ca16016f1f580}} 
\index{util.\+c@{util.\+c}!ierr\+\_\+coord\+\_\+fraction@{ierr\+\_\+coord\+\_\+fraction}}
\index{ierr\+\_\+coord\+\_\+fraction@{ierr\+\_\+coord\+\_\+fraction}!util.\+c@{util.\+c}}
\subsubsection{\texorpdfstring{ierr\+\_\+coord\+\_\+fraction}{ierr\_coord\_fraction}}
{\footnotesize\ttfamily int ierr\+\_\+coord\+\_\+fraction = 0}



Definition at line 223 of file util.\+c.

\mbox{\Hypertarget{util_8c_a0f0c8239c80e4ad569d9c18782b6f5cc}\label{util_8c_a0f0c8239c80e4ad569d9c18782b6f5cc}} 
\index{util.\+c@{util.\+c}!ierr\+\_\+where\+\_\+in\+\_\+2dcell@{ierr\+\_\+where\+\_\+in\+\_\+2dcell}}
\index{ierr\+\_\+where\+\_\+in\+\_\+2dcell@{ierr\+\_\+where\+\_\+in\+\_\+2dcell}!util.\+c@{util.\+c}}
\subsubsection{\texorpdfstring{ierr\+\_\+where\+\_\+in\+\_\+2dcell}{ierr\_where\_in\_2dcell}}
{\footnotesize\ttfamily int ierr\+\_\+where\+\_\+in\+\_\+2dcell = 0}



Definition at line 401 of file util.\+c.

