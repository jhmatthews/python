\hypertarget{macro__gov_8c}{}\section{/\+Users/mhewitt/python/source/macro\+\_\+gov.c File Reference}
\label{macro__gov_8c}\index{/\+Users/mhewitt/python/source/macro\+\_\+gov.\+c@{/\+Users/mhewitt/python/source/macro\+\_\+gov.\+c}}


is a file which contains the functions which govern macro-\/atoms and obtain their level populations. The actual functions which do the jumps inside an activated macro-\/atom are in \hyperlink{matom_8c}{matom.\+c}. This is partly done to prevent overly long files (J\+M1504)  


{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$math.\+h$>$}\newline
{\ttfamily \#include \char`\"{}atomic.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}python.\+h\char`\"{}}\newline
{\ttfamily \#include $<$gsl/gsl\+\_\+block.\+h$>$}\newline
{\ttfamily \#include $<$gsl/gsl\+\_\+vector.\+h$>$}\newline
{\ttfamily \#include $<$gsl/gsl\+\_\+matrix.\+h$>$}\newline
{\ttfamily \#include \char`\"{}my\+\_\+linalg.\+h\char`\"{}}\newline
Include dependency graph for macro\+\_\+gov.\+c\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{macro__gov_8c__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{macro__gov_8c_a7de597169a947d506f6d2210de2080ac}{macro\+\_\+gov} (\hyperlink{python_8h_ad2424d53ebcf811656882a87e11b440c}{Phot\+Ptr} p, int $\ast$\hyperlink{python_8h_ac1f90b11b79f8d2c9a25f12643063ee7}{nres}, int matom\+\_\+or\+\_\+kpkt, int $\ast$which\+\_\+out)
\begin{DoxyCompactList}\small\item\em is a routine that will sit at a higher level in the code than either matom or kpkt and will govern the passage of packets between these routines. At the moment, since matom and kpkt call each other it call all get rather confusing and loads of nested subroutine calls ensue. removes this by calling matom and kpkt which on return tell to either return an r-\/packet to resonate or make another call to either kpkt or matom as appropriate. \end{DoxyCompactList}\item 
int \hyperlink{macro__gov_8c_a590f1ed026cd692ac6f878ed6f359d5a}{macro\+\_\+pops} (\hyperlink{python_8h_a13ce7664e071685e1c3eaac3c32d7c8d}{Plasma\+Ptr} \hyperlink{compton_8c_ad65f0d74fe764d3ecae5ec1a89d63f08}{xplasma}, double xne)
\begin{DoxyCompactList}\small\item\em uses the Monte Carlo estimators to compute a set of level populations for levels of macro atoms. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
is a file which contains the functions which govern macro-\/atoms and obtain their level populations. The actual functions which do the jumps inside an activated macro-\/atom are in \hyperlink{matom_8c}{matom.\+c}. This is partly done to prevent overly long files (J\+M1504) 

\begin{DoxyAuthor}{Author}
ksl 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
January, 2018 
\end{DoxyDate}


\subsection{Function Documentation}
\mbox{\Hypertarget{macro__gov_8c_a7de597169a947d506f6d2210de2080ac}\label{macro__gov_8c_a7de597169a947d506f6d2210de2080ac}} 
\index{macro\+\_\+gov.\+c@{macro\+\_\+gov.\+c}!macro\+\_\+gov@{macro\+\_\+gov}}
\index{macro\+\_\+gov@{macro\+\_\+gov}!macro\+\_\+gov.\+c@{macro\+\_\+gov.\+c}}
\subsubsection{\texorpdfstring{macro\+\_\+gov()}{macro\_gov()}}
{\footnotesize\ttfamily int macro\+\_\+gov (\begin{DoxyParamCaption}\item[{\hyperlink{python_8h_ad2424d53ebcf811656882a87e11b440c}{Phot\+Ptr}}]{p,  }\item[{int $\ast$}]{nres,  }\item[{int}]{matom\+\_\+or\+\_\+kpkt,  }\item[{int $\ast$}]{which\+\_\+out }\end{DoxyParamCaption})}



is a routine that will sit at a higher level in the code than either matom or kpkt and will govern the passage of packets between these routines. At the moment, since matom and kpkt call each other it call all get rather confusing and loads of nested subroutine calls ensue. removes this by calling matom and kpkt which on return tell to either return an r-\/packet to resonate or make another call to either kpkt or matom as appropriate. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em Phot\+Ptr} & p the packet at the point of activation \\
\hline
\mbox{\tt out}  & {\em int} & $\ast$ nres the process which activates the Macro Atom \\
\hline
\mbox{\tt out}  & {\em int} & matom\+\_\+or\+\_\+kpkt to tell us if we should initially excite a \\
\hline
\mbox{\tt out}  & {\em int} & $\ast$ which\+\_\+out set to 1 if return is via macro atom and 2 if via kpkt \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Will return an r-\/packet after (possibly) several calls to matom and kpkt \begin{DoxyVerb}   int nres                    the process by which re-emission occurs
   PhotPtr p                   the packet following re-emission
\end{DoxyVerb}

\end{DoxyReturn}
\paragraph*{Notes}

I\textquotesingle{}ve written this to be as general as possible so that if we want to improve the treatment of simple ions it should not need to be re-\/written.

During the spectrum calculation the emission of r-\/packets within the spectral region of interest is done using emissivities obtained during the ionization cycles. Therefore whenever an r-\/packet is converted into a k-\/packet or an excited macro atom that ends the need to follow the packet any further. To deal with this, this routine sets the weights of such packets to zero. Upon return to trans\+\_\+phot these packets will then be thrown away. 

Definition at line 57 of file macro\+\_\+gov.\+c.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{macro__gov_8c_a7de597169a947d506f6d2210de2080ac_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=230pt]{macro__gov_8c_a7de597169a947d506f6d2210de2080ac_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{macro__gov_8c_a590f1ed026cd692ac6f878ed6f359d5a}\label{macro__gov_8c_a590f1ed026cd692ac6f878ed6f359d5a}} 
\index{macro\+\_\+gov.\+c@{macro\+\_\+gov.\+c}!macro\+\_\+pops@{macro\+\_\+pops}}
\index{macro\+\_\+pops@{macro\+\_\+pops}!macro\+\_\+gov.\+c@{macro\+\_\+gov.\+c}}
\subsubsection{\texorpdfstring{macro\+\_\+pops()}{macro\_pops()}}
{\footnotesize\ttfamily int macro\+\_\+pops (\begin{DoxyParamCaption}\item[{\hyperlink{python_8h_a13ce7664e071685e1c3eaac3c32d7c8d}{Plasma\+Ptr}}]{xplasma,  }\item[{double}]{xne }\end{DoxyParamCaption})}



uses the Monte Carlo estimators to compute a set of level populations for levels of macro atoms. 


\begin{DoxyParams}{Parameters}
{\em \mbox{[}in} & out\mbox{]} Plasma\+Ptr xplasma ??? \\
\hline
{\em \mbox{[}in} & out\mbox{]} double xne -\/$>$ current value for electron density in this shell \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Should compute the fractional level populations for macro atoms and store them in \char`\"{}levden\char`\"{} array. The ion fractions are also computed and stored in w\mbox{[}n\mbox{]}.density\mbox{[}nion\mbox{]}
\end{DoxyReturn}
\paragraph*{Notes}

This routine uses a matrix inversion method to get the level populations. For now the matrix solver used is the LU decomposition method provided by the Gnu Scientific Library (G\+SL, which is free). This requires the include files that I\textquotesingle{}ve added to the top of this file and access to the G\+SL \char`\"{}library\char`\"{} file (I\textquotesingle{}ve added the library into the Makefile too). I found G\+SL to be very easy to install but if there are problems in the future we may need to switch to another matrix solver. (SS, Apr 04)

We also clean for population inversion in this routine.

The details are in Matthews\textquotesingle{} thesis. 

Definition at line 221 of file macro\+\_\+gov.\+c.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{macro__gov_8c_a590f1ed026cd692ac6f878ed6f359d5a_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{macro__gov_8c_a590f1ed026cd692ac6f878ed6f359d5a_icgraph}
\end{center}
\end{figure}
